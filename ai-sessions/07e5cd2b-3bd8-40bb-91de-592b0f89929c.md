---
session_id: 07e5cd2b-3bd8-40bb-91de-592b0f89929c
session_name: "Tide DApp设计讨论与架构规划"
cwd: /home/alva/repos/tide
user_messages_count: 25
assistant_messages_count: 54
---

## 👤 User
*2026-02-08T09:00:49.601Z*

我准备写一个关于币价涨跌的预测竞猜Dapp，只猜测上涨还是下跌，比如设定某个币种 0x2::sui::SUI，然后采用某个 oracle 作为价格源（比如 pythnet, supra 啥的），设定为每 5min 开盘一次，最后30s截止投注，投注单位为 ticket，每个ticket需要花费5sui，手续费为2%，根据这个时间段的收盘价格和收盘价格，来判断是上涨还是下跌，胜者均分整个盘面的资金。
因为只需要猜涨跌，价格曲线如同潮汐一般，所以我给这个项目起名为 Tide。
这个和Polymarket比较像，同时我见过其他交易所也有类似的玩法，玩法规则并不难，你看看我们要怎么规划设计这个项目？
我们先进行讨论设计，后续再开始落地编码

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T09:00:59.417Z*

先看看当前项目结构，再来讨论设计。

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T09:01:22.717Z*

好的，项目目前是空壳状态——Move 合约和前端都还是脚手架。我来先查一下 Sui 上主流 Oracle 的集成方式，然后我们来讨论整体架构。

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T09:02:40.243Z*

好，信息收集完毕。下面是 Tide 项目的完整架构设计讨论。

---

## Tide 架构设计

### 一、Oracle 选择：Pyth Network

对比了 Pyth 和 Supra：
- **Pyth**：Sui 集成干净简洁，API 只需 `PriceInfoObject` + `Clock`，文档清晰，有现成 SUI/USD price feed ID
- **Supra**：Pull Oracle 需要传入大量签名验证参数（20+个 vector 参数），集成复杂度高很多

**建议用 Pyth**。集成代码量少一个数量级，且 Pyth 在 DeFi 领域的采用率更高。

### 二、系统分三层

```
┌─────────────┐    ┌──────────────┐    ┌─────────────────┐
│  Frontend    │    │  Keeper/Crank│    │  Move Contract   │
│  (React)     │───▶│  (TS Script) │───▶│  (on-chain)      │
│  用户下注/领奖│    │  自动开/结算  │    │  核心业务逻辑     │
└─────────────┘    └──────────────┘    └─────────────────┘
                          │
                   ┌──────▼──────┐
                   │ Pyth Hermes │
                   │ (价格源)     │
                   └─────────────┘
```

### 三、Move 合约核心设计

**对象模型：**

| 对象 | 类型 | 说明 |
|------|------|------|
| `AdminCap` | owned | 管理员权限，控制手续费/暂停等 |
| `Market` | shared | 全局状态：fee_rate, ticket_price, treasury余额, round计数 |
| `Round` | dynamic field on Market | 每轮状态：开盘价/收盘价/时间戳/资金池 |
| `Ticket` | owned (用户持有) | 下注凭证：round_id, 方向(UP/DOWN), ticket数量 |

**Round 生命周期：**

```
  t=0:00          t=4:30           t=5:00
    │               │                │
    ▼               ▼                ▼
  OPEN ──────────► LOCKED ────────► SETTLED
  (记录开盘价,      (停止下注,        (记录收盘价,
   接受投注)        等待结算)         可领奖)
```

- 不需要单独的 LOCKED 状态字段，合约内用 `clock.timestamp < round.start_time + 270s`（4分30秒）来判断是否可下注
- Keeper 在 t=5:00 时调用 `close_round`，传入 Pyth 价格完成结算

**核心函数：**

```
create_market(ctx) → Market + AdminCap
start_round(market, clock, pyth_price_info) → 创建新Round，记录开盘价
place_bet(market, round_id, direction, payment: Coin<SUI>, clock) → Ticket
close_round(market, round_id, clock, pyth_price_info) → 结算Round
claim(market, round_id, ticket) → 按比例派奖
```

**资金流：**
- 用户下注 → SUI 进入 Round 的 up_pool 或 down_pool
- 结算时 → total_pool × 2% = 手续费进 treasury，剩余按 ticket 比例分给胜方
- 胜方每张 ticket 的收益 = (total_pool × 98%) / winning_tickets

### 四、需要讨论的边界情况

1. **平局（收盘价 == 开盘价）**：建议全额退款，不收手续费。这对用户最公平。
2. **单边投注（只有UP或只有DOWN）**：建议全额退款，不收手续费。否则赢家实际亏损（5 SUI → 4.9 SUI）。
3. **无人投注**：Round 正常结算，无需处理。
4. **Round 内是否限制最大投注量**：初期不限制，后续可加。
5. **用户能否一次买多张 Ticket**：建议支持，一次传入 N × 5 SUI。
6. **支持的币种**：初期只做 SUI/USD，合约设计可预留扩展接口支持多币种 Market。

### 五、Keeper（后端自动化）

一个简单的 TypeScript 定时脚本：
- 每 5 分钟执行一次：`close_round(上一轮)` + `start_round(新一轮)` 可合并为一笔交易
- 从 Pyth Hermes 拉取最新价格，作为交易参数传入
- 需要一个有 gas 的钱包来签名

### 六、前端（React）

已有 dApp Kit + Tailwind 基础，需要的核心页面：
- **主面板**：当前轮状态 + 倒计时 + 上涨/下跌按钮 + 资金池分布
- **历史记录**：过往轮次结果
- **我的 Tickets**：用户持有的票据 + 一键领奖

---

**几个问题想确认：**

1. 平局和单边投注的处理你同意「全额退款」方案吗？
2. 初期是否只做 SUI/USD 单一市场，还是一开始就设计多市场架构？
3. Keeper 的部署方式有偏好吗？简单 cron job 还是用 Sui 的 programmable transaction + 某种触发机制？
4. 前端风格有参考吗？Polymarket 风格？还是更像交易所的 binary option 面板？

## 👤 User
*2026-02-08T09:26:42.143Z*

1. 平均，单边投注甚至其他情况（比如预言机异常，管理员手动取消等）都全额退款，不做手续费扣除；
2. 我的想法是提前就设计好多市场架构，先是多币种(sui/usd, eth/usd, wal/usd 等），然后是多时间跨度（1min/5min/1h等）；不同时间跨度的停止下注时间可能不太一样。
3. 关于结算的触发方式，暂时还没想到好的方法，有一个后端确实好用的，但是有不需要额外后端的方式吗？毕竟感觉这样不太中心化。还是说这个触发器还是有必要的。对于这个结算的动作，是不是可以用 treasury(from fee) 作为手续费来源
4. 前端界面的设计暂时还没想好。
5. 对于每个时间段的轮次，你觉得截止投注的时机要放在什么时候比较好？当前轮次的前x秒？当前轮次开始前/时？
6. 结算时，需要分发奖金，如果轮次内投注的人很多，涉及的 tx 会不会很大？同时也会影响 gas，这个要怎么处理？保持现状，又或者是分多个 tx？又或者限制轮次投注人数，然后同一个轮次分不同盘？感觉这样子又平添复杂度。还是说设置为用户主动领取？这样有必要吗？

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T09:28:08.716Z*

这些问题都很关键，逐个分析。

## 3. 去中心化结算

完全不用后端是可以做到的。核心思路：**结算函数设为 permissionless，任何人都可以调用，用手续费激励**。

```
close_round() → 任何人在 round.end_time 之后都可调用
  → 调用者从 fee pool 获得一笔小额奖励（比如 0.1 SUI）
  → 经济激励自然催生第三方 keeper bot 生态
```

这是 DeFi 的标准做法（PancakeSwap Prediction、Chainlink Keepers 思路类似）。用 treasury 支付结算激励完全合理——手续费本来就是协议收入，拿一部分出来维持协议运转是正当的。

不过现实地说：**初期建议还是自己跑一个 keeper**，等协议 TVL 上来、fee pool 足够大了，第三方 bot 自然会进场。合约层面只需确保 `close_round()` 是 permissionless 的即可。

## 5. 截止投注时机

这里有两种模型：

**模型 A：轮内投注 + 截止时间**（你原来的设想）
```
|------- 可投注 --------|-- 锁定 --|
t=0                   t=cutoff   t=end
记录开盘价                        记录收盘价
```
问题：用户在轮内可以观察价格走势再下注，越晚下注信息优势越大，cutoff 就是为了限制这个。

**模型 B：提前投注，下一轮生效**（PancakeSwap 模式）
```
Round N:  |====== LIVE（追踪价格）======|
Betting:  |==== 投注 Round N+1 ========|-- 锁定 --|
```
投注时完全不知道价格走势，更公平，但 UX 上有一个"延迟感"。

**我的建议：用模型 A，但 cutoff 比例按时间跨度调整。** 原因是简单直接、符合用户直觉（"我看到当前轮，我下注当前轮"），而且这类竞猜本质是娱乐，绝对公平性不是第一优先级。

| 时间跨度 | 锁定时间 | 投注窗口 | 锁定占比 |
|---------|---------|---------|---------|
| 1min    | 最后 10s | 50s     | ~17%    |
| 5min    | 最后 30s | 4m30s   | 10%     |
| 15min   | 最后 2min | 13min  | ~13%    |
| 1h      | 最后 5min | 55min  | ~8%     |

这个参数存在 Market 配置里，每个市场可独立设置。

## 6. 结算分发方式

这是最关键的可扩展性问题。答案很明确：**用户主动 claim（pull 模式）**。

```
close_round():
  - 只做一件事：记录收盘价，计算结果（UP/DOWN/DRAW）
  - O(1) 复杂度，gas 恒定

claim(ticket):
  - 用户提交自己的 Ticket
  - 合约计算：reward = (total_pool × 98%) × (my_tickets / winning_tickets)
  - 发放 SUI，销毁 Ticket
  - O(1) 复杂度
```

这是 DeFi 标准模式，好处是：
- 结算 tx 极轻，不受参与人数影响
- 每人 claim 自己承担 gas
- 无 tx 大小上限问题
- 不需要分片或限制人数

未领取的奖金可以设一个过期时间（比如 7 天），过期后回归 treasury。

---

## 修订后的整体架构

```
                    MarketRegistry (shared, singleton)
                    ├── config: fee_rate, settler_reward
                    ├── treasury: Balance<SUI>
                    │
                    ├── Market "SUI/USD-5min"
                    │     ├── pyth_feed_id
                    │     ├── interval_ms: 300_000
                    │     ├── lock_duration_ms: 30_000
                    │     ├── ticket_price: 5 SUI
                    │     ├── Round #1 { open_price, close_price, up_pool, down_pool, status }
                    │     ├── Round #2
                    │     └── ...
                    │
                    ├── Market "ETH/USD-1min"
                    │     └── ...
                    └── Market "WAL/USD-1h"
                          └── ...

用户持有:
  Ticket { market_id, round_id, direction, amount }
```

**合约函数修订版：**

| 函数 | 权限 | 说明 |
|------|------|------|
| `create_registry(ctx)` | 一次性 | 创建 Registry + AdminCap |
| `create_market(admin, registry, feed_id, interval, lock_duration, ticket_price)` | admin | 新建市场 |
| `start_round(registry, market_id, clock, pyth_price)` | anyone | 开启新轮，需上一轮已结算 |
| `place_bet(registry, market_id, round_id, direction, payment, clock)` | anyone | 下注，返回 Ticket |
| `close_round(registry, market_id, round_id, clock, pyth_price)` | anyone | 结算，调用者获 settler reward |
| `claim(registry, market_id, ticket)` | ticket holder | 领奖，销毁 Ticket |
| `refund(registry, market_id, ticket)` | ticket holder | 平局/取消时退款 |
| `cancel_round(admin, registry, market_id, round_id)` | admin | 异常时手动取消 |
| `pause_market(admin, registry, market_id)` | admin | 暂停市场 |

**Round 状态机：**
```
OPEN → LOCKED → SETTLED
  │                ↗
  └→ CANCELLED ──┘  (都可 refund)
```

---

你对这个修订后的架构有什么想法？几个还需确认的点：

1. **Ticket 价格**：固定 5 SUI 且只能整数倍购买，还是允许任意金额下注？固定面额更简单，但任意金额灵活度更高。
2. **settler reward 的金额**：你觉得给结算触发者多少合适？需要覆盖 gas + 一点利润。
3. **未领奖金过期时间**：是否需要？多长？

## 👤 User
*2026-02-08T10:14:13.550Z*

1. UI 上，可以显示前 n 场的结果，当前场的动态信息，和下一场的投注，以及未来几场的开始倒计时。同时也提供价格图表（TradingView, Pythnet等），需要提醒用户，显示的价格仅供参考，而游戏采用的价格源是使用 pythnet 预言机等
2. 暂时就定位 SUI/BTC/ETH 等多个币种，时间段就只开放一个 5min 。同时限定只能投注下一场
3. 可以提供一个排行榜，显示某个竞技场下的排名，显示胜率，金额，场次等
4. 奖金/退款（如果流局等）由个人主动 claim 进行领取
5. 关于 ticket 价格问题，固定面额和任意金额的方式我都觉得不错，说说优劣，另外我们是不是可以采取发行币种的形式？我对这类形式不太熟悉
6. 关于结算触发的事情，我们可以做到：前期设置权限，只能由我进行触发，后续根据情况再考虑公开权限，允许第三方bot的形式吗？对于奖励金额，也设置参数就行了，比如奖金池的 1point
7. 过期奖金的问题，这个如果设置，比如7天，那要怎么计算？谁来计算？也是类似结算触发的形式？然后奖励触发者一部分金额，同时剩余的返还 treasury？这样的机制好吗？

## 🤖 Assistant (<synthetic>)
*2026-02-08T10:17:18.692Z*

API Error: 500 {"error":{"message":"auth_unavailable: no auth available","type":"server_error","code":"internal_server_error"}}

## 👤 User
*2026-02-08T10:18:39.968Z*

1. UI 上，可以显示前 n 场的结果，当前场的动态信息，和下一场的投注，以及未来几场的开始倒计时。同时也提供价格图表（TradingView, Pythnet等），需要提醒用户，显示的价格仅供参考，而游戏采用的价格源是使用 pythnet 预言机等
2. 暂时就定位 SUI/BTC/ETH 等多个币种，时间段就只开放一个 5min 。同时限定只能投注下一场
3. 可以提供一个排行榜，显示某个竞技场下的排名，显示胜率，金额，场次等
4. 奖金/退款（如果流局等）由个人主动 claim 进行领取
5. 关于 ticket 价格问题，固定面额和任意金额的方式我都觉得不错，说说优劣，另外我们是不是可以采取发行币种的形式？我对这类形式不太熟悉
6. 关于结算触发的事情，我们可以做到：前期设置权限，只能由我进行触发，后续根据情况再考虑公开权限，允许第三方bot的形式吗？对于奖励金额，也设置参数就行了，比如奖金池的 1point
7. 过期奖金的问题，这个如果设置，比如7天，那要怎么计算？谁来计算？也是类似结算触发的形式？然后奖励触发者一部分金额，同时剩余的返还 treasury？这样的机制好吗？

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T10:21:32.010Z*

好，逐条回应。

## 2. "只能投注下一场"→ 流程重构

这个决定让架构变得更干净。新流程：

```
时间轴:
Round N:   |========= LIVE (追踪价格) =========|
Round N+1: |===== UPCOMING (接受投注) ==========|→ 变 LIVE
Round N+2:                                      |=== UPCOMING ===...

事件:      ^记录 N 开盘价                        ^结算 N
           ^N+1 开始接受投注                      ^记录 N+1 开盘价
                                                 ^N+2 开始接受投注
```

由于用户下注的是**尚未开始**的轮次，根本看不到价格走势，**不需要锁定期**。投注窗口 = 上一轮的全部时长（5min）。投注截止 = 下一轮开始的瞬间（即上一轮结算时）。

**Round 状态机修订：**
```
UPCOMING → LIVE → SETTLED
    │                ↗
    └→ CANCELLED ──┘
```

## 5. Ticket 定价：三种方案对比

| | 固定面额 (5 SUI/张) | 任意金额 | 代币形式 |
|---|---|---|---|
| **计算** | reward = pool × 98% / winning_tickets | reward = pool × 98% × (my_bet / winning_total) | 同任意金额，但用自定义 Coin |
| **优点** | 极简，UI 清晰，"买几张"直觉好 | 灵活，低门槛（0.1 SUI 也能玩） | 可组合性强，理论上可二级交易 |
| **缺点** | 门槛固定，大户小户体验差异大 | 计算稍复杂（其实就多一次除法） | Sui 上每轮创建新 Coin type 不现实 |
| **适合** | 纯娱乐、低频 | 大众化、不同用户群体 | 长周期市场（天/周级别） |

关于"发行币种"：在 Sui 上，Coin 类型是编译期确定的，无法为每轮动态创建新代币。要做到类似 Polymarket 的 YES/NO token，需要设计一个通用的 Position Coin，但对 5 分钟轮次来说二级交易几乎没有意义（还没交易就到期了）。

**建议：用任意金额方案**。设一个最低投注额（比如 1 SUI），不设上限。Ticket 对象本身就是"仓位凭证"，功能上等价于代币但更简单。后续如果开长周期市场，再考虑代币化。

## 6. 结算权限：渐进式开放

完全可以。设计一个 `SettlerCap`：

```
Phase 1 (初期): close_round() 要求传入 SettlerCap (你持有)
Phase 2 (开放): 新增 close_round_public() 无需 cap，permissionless
               通过 AdminCap 切换模式
```

settler reward 设为可配参数，存在 Registry 里。1bp（万分之一）合理，以 1000 SUI 池子为例奖励 0.1 SUI，远超 Sui gas 费（通常 < 0.01 SUI），足以激励 bot。

## 7. 过期奖金：sweep 机制

```
sweep_expired(registry, market_id, round_id, clock)
  ├── 校验: clock.now > round.settled_at + EXPIRY_DURATION (如 7 天)
  ├── 将 round 剩余 Balance 全部转出
  │     ├── sweep_reward → 调用者 (如 1% of remaining)
  │     └── 剩余 → treasury
  └── 标记 round 为 EXPIRED

claim() 中增加校验:
  └── if round.status == EXPIRED → abort E_ROUND_EXPIRED
```

这是 O(1) 操作——不需要遍历任何 ticket。7 天怎么算？纯链上时间戳比较：`clock::timestamp_ms(clock) > round.settled_at_ms + 7 * 86400 * 1000`。

触发形式和结算一样，前期你手动 sweep，后期可以开放 permissionless + reward。

---

## 修订后完整架构

```
Registry (shared)
├── admin: AdminCap holder
├── config
│   ├── fee_bps: u64 (200 = 2%)
│   ├── settler_reward_bps: u64 (1 = 0.01%)
│   ├── sweep_reward_bps: u64 (100 = 1%)
│   ├── expiry_ms: u64 (7 days)
│   ├── min_bet: u64
│   └── settler_mode: PERMISSIONED | PUBLIC
├── treasury: Balance<SUI>
│
├── Market "SUI/USD"
│   ├── pyth_feed_id: vector<u8>
│   ├── interval_ms: 300_000
│   ├── ticket_price_min: 1 SUI
│   ├── status: ACTIVE | PAUSED
│   ├── current_round: u64
│   ├── Round #N  (LIVE)   { open_price, open_ts, up_pool, down_pool }
│   ├── Round #N+1 (UPCOMING) { up_pool, down_pool }
│   └── stats: { total_volume, total_rounds }
│
├── Market "BTC/USD" ...
└── Market "ETH/USD" ...

User holds:
  Ticket { market_id, round_id, direction: UP|DOWN, amount: u64 }

Leaderboard (per market):
  UserStats { wins, losses, draws, total_bet, total_won, net_profit }
```

**合约函数最终版：**

| 函数 | 权限 | 说明 |
|---|---|---|
| `create_registry` | 一次性 | 初始化 |
| `create_market` | admin | 新建市场 |
| `settle_and_advance` | settler | 结算当前轮 + 开启下下轮，单笔 tx |
| `place_bet` | anyone | 投注下一轮，返回 Ticket |
| `claim` | ticket holder | 胜者领奖 |
| `refund` | ticket holder | 平局/取消退款 |
| `sweep_expired` | anyone/settler | 回收过期未领奖金 |
| `cancel_round` | admin | 取消轮次 |
| `pause_market` / `resume_market` | admin | 暂停/恢复 |
| `update_config` | admin | 修改参数 |

`settle_and_advance` 是核心——一笔交易完成：结算 Round N → Round N+1 变 LIVE（记录开盘价）→ 创建 Round N+2（UPCOMING）。

---

**排行榜实现**：用 dynamic field 在 Market 下存 `UserStats`，`place_bet` 和 `claim` 时更新。链上存数据，前端读取展示。

还有什么想调整的？如果大方向定了，我可以开始整理最终的技术规格文档，然后着手编码。

## 👤 User
*2026-02-08T10:39:49.358Z*

1. 关于 ticket，采取任意金额的方案；
2. 除了每个 market 有单独的开关状态，建议总的也有一个，不仅影响轮次的启动结束结算等，也影响其他动作（如果有）；

暂时看起来没什么需要调整的了，你先将我们的讨论落实为文档吧，从项目背景、设计、考虑、参考内容等等都要囊括进去，不需要太详尽的代码细节。我后续再重新审查下

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T10:40:07.655Z*

好，整理设计文档。先确认下目录结构。

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T10:43:11.156Z*

文档已写入 `docs/design.md`。涵盖内容：

- **项目背景与灵感来源**（Polymarket / PancakeSwap / 交易所 binary option）
- **核心玩法**：投注下一轮、任意金额、pull 领奖、异常全额退款
- **轮次状态机**：UPCOMING → LIVE → SETTLED → EXPIRED，加 CANCELLED 分支
- **系统架构图**：合约 / Keeper / 前端 / Pyth 四层
- **合约对象模型**：Registry → Market → Round → Ticket 完整结构
- **所有合约函数**：初始化、管理、结算、用户操作、维护五类
- **资金流**：从 place_bet 到 fee → treasury → claim → sweep 全链路
- **Oracle 集成**：Pyth feed ID、价格比较逻辑、过期保护
- **Keeper 分阶段设计**：Phase 1 权限制 → Phase 2 公开
- **前端规划**：主面板、市场切换、我的投注、排行榜
- **排行榜**：链上 UserStats + 多维排序
- **安全考量**：经济安全、合约安全、运营安全
- **7 条 ADR**：记录所有关键设计决策及理由
- **未来扩展**：多时间跨度、更多资产、锦标赛模式等

你审阅后告诉我需要调整什么，定稿后就可以开始编码了。

## 👤 User
*2026-02-08T10:45:19.028Z*

1. 关于 ticket，采取任意金额的方案；
2. 除了每个 market 有单独的开关状态，建议总的也有一个，不仅影响轮次的启动结束结算等，也影响其他动作（如果有）；

暂时看起来没什么需要调整的了，你先将我们的讨论落实为文档吧，从项目背景、设计、考虑、参考内容等等都要囊括进去，不需要太详尽的代码细节，用中文来编写。我后续再重新审查下

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T10:45:28.217Z*

好，我来将所有讨论内容整理为一份完整的设计文档。

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T10:47:56.257Z*

设计文档已写入 `docs/design.md`，涵盖：

- **项目背景**：定位、玩法、参考产品
- **系统架构**：三层架构图、技术栈
- **预言机选型**：Pyth vs Supra 对比及决策依据
- **合约设计**：对象模型、Round 生命周期、函数表、资金流、边界情况、两级暂停机制
- **结算机制**：渐进式去中心化（PERMISSIONED → PUBLIC）
- **排行榜**：数据结构、更新时机
- **前端**：页面布局草图、价格图表提示、技术要点
- **开发规划**：Phase 1-4 路线图
- **安全考虑**：合约/经济/预言机三个维度
- **参考资料**：所有相关链接

新增了你提到的**全局暂停开关**——所有写操作需同时满足 `global_status == ACTIVE && market.status == ACTIVE`。

你审阅后有任何需要调整的地方告诉我。

## 👤 User
*2026-02-08T13:29:50.560Z*

看了设计文档后，我给出几个意见：
1. 对于结算机制上，按你的设计，一个 keeper bot 检查时，是拉取最新价格，我觉得不太妥当，我们能不能做到使用收盘时刻的价格？
2. keeper 奖励的机制先行取消掉吧，并且把关于开放结算许可的规划也取消掉，暂时没必要了。
3. 关于排行榜这个，是怎么做到查询前x名的？

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T13:30:42.534Z*

三个问题都很关键，逐个回答。

## 1. 收盘价格时效性

你说得对，"拉取最新价格"不严谨。Pyth Hermes 支持查询指定时间戳的历史价格：

```
GET /v2/updates/price/{publish_time}?ids[]=<feed_id>
```

所以正确流程是：

```
Keeper:
  1. 等待 round.end_time 到达
  2. 向 Pyth Hermes 请求 round.end_time 时刻的价格
  3. 提交该价格到合约

合约侧校验:
  price_timestamp = price::get_timestamp(&price_struct)
  assert!(|price_timestamp - round.end_time_sec| <= TOLERANCE)
  // TOLERANCE 如 5~10 秒，因为预言机更新是离散的，不会精确到秒
```

同理，开盘价也应该做时间戳校验——确保是 `round.start_time` 附近的价格。这样即使 keeper 延迟了几秒触发结算，使用的仍然是收盘时刻的价格。

## 2. 移除 keeper 奖励和开放结算

了解，简化后结算机制就是：

- `settle_and_advance` 始终要求 `SettlerCap`
- 不设结算奖励
- 移除 `settler_mode` / `settler_reward_bps` 配置项
- 从开发规划中移除 Phase 3 "去中心化结算"

## 3. 排行榜查询

这个问题触及了链上存储的根本局限：**Sui（以及几乎所有链）的 Dynamic Field 不支持排序查询**。你无法在合约里 `SELECT * ORDER BY wins DESC LIMIT 10`。

两种方案：

| | 链上 UserStats + 链下索引 | 纯链下索引（事件驱动） |
|---|---|---|
| 做法 | 合约里存 UserStats，但排行榜靠链下索引查询 | 合约只发 Event，链下索引聚合计算所有统计 |
| 链上成本 | 每次 bet/claim 都要更新 UserStats，增加 gas | 只发 Event，gas 开销小 |
| 数据可验证性 | 个人数据链上可查 | 需信任索引器 |
| 复杂度 | 合约更复杂 | 合约更简单 |

**建议：纯链下索引方案。** 理由：

1. 排行榜本身就是展示性功能，不参与链上逻辑
2. 省掉每次 bet/claim 更新 UserStats 的 gas
3. 合约更精简，减少攻击面
4. Sui 有成熟的事件索引基础设施（GraphQL API / 自建 indexer）

合约只需在关键动作时发出结构化 Event：

```
// 事件定义
struct BetPlaced has copy, drop {
    market_id: ID,
    round_id: u64,
    player: address,
    direction: u8,
    amount: u64,
}

struct RoundSettled has copy, drop {
    market_id: ID,
    round_id: u64,
    result: u8,
    open_price: u64,
    close_price: u64,
    up_amount: u64,
    down_amount: u64,
}

struct Claimed has copy, drop {
    market_id: ID,
    round_id: u64,
    player: address,
    amount: u64,     // 领取金额
    bet_amount: u64, // 原投注金额
}

struct Refunded has copy, drop { ... }
```

链下索引器订阅这些 Event，聚合出每个用户的胜率、盈亏、场次等数据，前端从索引器 API 查询排行榜。

---

我现在更新设计文档，反映这三点变更。

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T13:30:53.122Z*

文件已读取，现在批量更新三处变更。

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T13:32:48.466Z*

Now update the sweep_expired section to also use SettlerCap and remove the sweep reward references:

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T13:33:16.787Z*

文档已更新完毕。变更汇总：

1. **价格时间戳校验**：Pyth 集成部分新增了 Hermes 历史价格 API 说明和合约侧 `PRICE_TOLERANCE` 校验逻辑，确保开盘价/收盘价使用的是对应时刻的价格而非"最新价格"
2. **结算机制简化**：移除 `settler_mode`、`settler_reward_bps`，`settle_and_advance` 始终要求 `SettlerCap`；移除 Phase 3 去中心化规划；`sweep_expired` 同样改为 SettlerCap 权限
3. **排行榜改为纯链下索引**：合约不再存储 UserStats，只发出结构化 Event（`BetPlaced`/`RoundSettled`/`Claimed`/`Refunded`），由链下索引器聚合排行数据

config 字段也同步精简，移除了 `settler_reward_bps`、`sweep_reward_bps`、`settler_mode`，新增 `price_tolerance_sec`。

## 👤 User
*2026-02-08T13:37:24.676Z*

排行榜采用合约事件+纯链下索引的方式，不存储 UserStats。那么如果链下索引器第一次启动/重启，要怎么恢复现场？再加一个数据库吗？如果数据库记录清空呢？重新恢复就需要重新拉取是吗？

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T13:37:50.171Z*

对，但这不是问题。

Sui 的事件是**永久存储在链上**的，不是临时数据。索引器本质上就是链上事件的一个物化视图（materialized view），任何时候都可以从头重建。

实际工作方式：

```
索引器运行时:
  1. 记录 cursor（最后处理到的 checkpoint/tx_digest）
  2. 持续拉取新事件，更新数据库

正常重启:
  → 从 cursor 继续，增量同步

数据库清空 / 首次启动:
  → 从合约部署的第一笔交易开始，全量重放所有事件
  → 对于 Tide 这种规模，全量重放可能就几秒到几分钟
```

Sui RPC 提供了 `queryEvents` 接口，支持按 package/module 过滤、分页游标遍历。GraphQL API 同理。所以数据库只是缓存层，链才是数据源，丢了随时可以重建。

需要一个数据库（SQLite/PostgreSQL 都行），但它不是"权威数据"——链上事件才是。这和区块链浏览器、DEX 的 K 线服务本质上是同一个模式。

这部分不需要改设计文档，属于索引器的实现细节，等到开发 Phase 2 排行榜时再具体设计。

## 👤 User
*2026-02-08T14:13:01.295Z*

关于合约的模型设计，我看到你打算用 dynamic field 来存储 Market 和 Round。为什么要用 dynamic field？对于实际使用的场景，会有什么问题吗？
比如前者 Market，可以用 vector<Market> 或者 Table<Market_id(u32), Market> 来存储吗？
对于后者 Round，按照5min一次来计算，一年就会累计10w+，对于合约/链下的查询/操作会带来啥影响吗？我看到有 vector<T>, Table<K, V>, ObjectTable<K, V> 等数据结构，这些有用吗？对于链下查询操作，比如前端查询当前轮次，下个轮次的动作，会有影响吗？现在sui node支持 grpc(首推) 和 jsonRpc(不再支持)，我更希望用前者来。

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T14:14:18.605Z*

这个问题很关键，直接影响合约的性能和可扩展性。

## Market 存储

先说核心问题：**对象争用（object contention）**。

Sui 上 shared object 的每笔交易都要走共识。如果所有 Market 数据都内嵌在 Registry 里（无论 vector 还是 Table），那 SUI/USD 的下注和 BTC/USD 的下注都要争抢同一个 Registry 对象锁——这是严重瓶颈。

| 方案 | 访问方式 | 争用情况 |
|------|---------|---------|
| `vector<Market>` 内嵌 Registry | 读任何 market 加载全部 | 所有市场共用一把锁 |
| `Table<K, Market>` 在 Registry 下 | O(1) 按 key 访问 | 仍然锁 Registry |
| **Market 作为独立 shared object** | 直接按 object ID 访问 | 各市场互不干扰 |

**建议：每个 Market 是独立的 shared object。** Registry 退化为一个轻量注册表，只存 Market ID 列表和全局配置。SUI/USD 市场的交易完全不影响 BTC/USD 市场。

```
Registry (shared) ← 仅全局配置 + market ID 列表，极少被写入
├── global_status
├── config (fee_bps, min_bet, ...)
├── treasury: Balance<SUI>
└── market_ids: vector<ID>    ← 市场数量少（个位数），vector 足够

Market "SUI/USD" (shared) ← 独立对象，独立锁
├── pyth_feed_id
├── interval_ms
├── current_round_id: u64
├── upcoming_round_id: u64
├── rounds: Table<u64, Round>  ← 或 ObjectTable
└── ...

Market "BTC/USD" (shared) ← 另一把锁，不冲突
└── ...
```

## Round 存储

5min 一轮，一年 ~105,000 轮。各方案对比：

| 方案 | 链上访问 | 10 万轮后的影响 | 链下查询 |
|------|---------|----------------|---------|
| `vector<Round>` | O(1) 按索引，但**加载整个 vector** | 灾难性：每次操作加载 10 万个 Round | 一次拿全部，内存爆炸 |
| `Table<u64, Round>` | O(1)，只加载目标 Round | 无影响，闲置 Round 只占存储 | 按 key 查单个 O(1) |
| `ObjectTable<u64, Round>` | 同上，且 Round 有独立 object ID | 同上 | 可直接按 object ID 查 |

`vector` 排除。`Table` 和 `ObjectTable` 的区别：

- `Table<u64, Round>`：Round 没有独立 object ID，通过父对象 + key 访问（`getDynamicFieldObject(market_id, round_key)`）
- `ObjectTable<u64, Round>`：Round 是独立 Sui object，有自己的 ID，可直接 `getObject(round_id)` 查询

**建议用 `ObjectTable`。** 理由：前端经常需要直接查询特定 Round（当前轮、下一轮），Round 有独立 object ID 更方便。Market 里存 `current_round_id` 和 `upcoming_round_id` 两个 object ID，前端一次读 Market 就知道该查哪两个 Round。

## 链下查询流程

前端（gRPC/GraphQL）的典型查询路径：

```
1. 读 Market 对象
   → 拿到 current_round_id, upcoming_round_id

2. 并行读两个 Round 对象（用 object ID 直接读）
   → 当前轮状态 + 下一轮投注池

3. 历史轮次：按 round 序号范围查
   → ObjectTable 的 dynamic field 遍历，或通过事件索引
```

全部是 O(1) 查询，10 万轮和 10 轮没有性能差异。

## 修订后的对象模型

```
Registry (shared)
├── global_status: u8
├── config: Config { fee_bps, min_bet, expiry_ms, price_tolerance_sec }
├── treasury: Balance<SUI>
└── market_ids: vector<ID>

Market (shared, 每个市场独立)
├── id: UID
├── registry_id: ID                      ← 关联 Registry
├── pyth_feed_id: vector<u8>
├── interval_ms: u64
├── status: u8
├── round_count: u64
├── current_round_id: Option<ID>         ← LIVE 轮的 object ID
├── upcoming_round_id: Option<ID>        ← UPCOMING 轮的 object ID
└── rounds: ObjectTable<u64, Round>      ← key=轮次序号, value=Round 对象

Round (object, 存于 ObjectTable 内)
├── id: UID
├── round_number: u64
├── status: u8
├── open_price / close_price / ...
├── pool: Balance<SUI>
└── ...
```

这样 `place_bet` 的交易只锁对应的 Market 对象，不同市场完全并行。读 Round 通过 object ID 直接访问，不受历史数据量影响。

要不要我把这些更新到设计文档里？

## 👤 User
*2026-02-08T14:25:48.266Z*

1. Market 的存储也能用 ObjectTable 吗？能做到直接查出来有哪些 Market 吗？
2. Round 查询上，如果我想查询 current_round 的前几个呢？要怎么做？比如我界面上想显示前3个轮次的结果

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T14:26:36.820Z*

## 1. Market 存储

不建议用 ObjectTable 存 Market。原因回到争用问题——ObjectTable 的值虽然有独立 object ID，但 `borrow_mut` 仍需要对父对象（Registry）加锁。放进 ObjectTable 等于把所有市场又绑回同一把锁。

Market 就做独立 shared object，Registry 只存一个 `vector<ID>`：

```
读取流程:
  1. getObject(registry_id) → vector<ID> [market_a, market_b, market_c]
  2. multiGetObjects([market_a, market_b, market_c]) → 所有 Market 详情
```

市场数量是个位数，`vector<ID>` 完全够用。两次查询拿到全部市场信息。

## 2. 查询前几轮

当前设计下，你知道 `current_round_number = N`，想查 N-1、N-2、N-3，需要通过 ObjectTable 做 3 次 dynamic field 查询。可行但不够直接。

更好的方式：**Market 里直接缓存最近几轮的 object ID**。

```
Market (shared)
├── ...
├── current_round_id: Option<ID>
├── upcoming_round_id: Option<ID>
├── recent_settled_ids: vector<ID>   ← 最近 N 轮已结算 Round 的 ID，FIFO
└── rounds: ObjectTable<u64, Round>  ← 全量存储，用于 claim/refund/历史深查
```

`settle_and_advance` 时维护这个 vector：

```
// 伪代码
vector::push_back(&mut market.recent_settled_ids, settled_round_id);
if (vector::length(&market.recent_settled_ids) > MAX_RECENT) {
    vector::remove(&mut market.recent_settled_ids, 0);  // 踢掉最老的
}
```

前端查询路径：

```
1. getObject(market_id)
   → current_round_id, upcoming_round_id, recent_settled_ids: [R_n-1, R_n-2, R_n-3]

2. multiGetObjects([current, upcoming, R_n-1, R_n-2, R_n-3])
   → 一次拿到全部需要的 Round 数据
```

两次 RPC 调用，拿到当前轮 + 下一轮 + 最近 3 轮历史，不依赖 ObjectTable 遍历。

更深的历史（比如用户翻页查第 50-60 轮），走事件索引器查。

---

要我把这些存储设计的变更更新到设计文档？

## 👤 User
*2026-02-08T14:34:51.813Z*

1. Market 倒是可以用 Vector<id> + 独立 object 的形式，而 Round 就用 ObjectTable<u64, Round> 的形式保存到 Market 中时，place_bet 操作锁对应的 Market 对象，这不会影响到其他用户的 place_bet, claim 操作吗？
2. 你说的走事件索引器查更深的历史，是什么意思？怎么操作？
3. 对于用户的个人数据，又该怎么查询呢？比如在界面上倒序显示我这个钱包的竞猜记录，并显示结果，收益/亏损。另外我还想显示这个钱包总的数据

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T14:36:03.669Z*

## 1. Market 争用

是的，同一个 Market 内的 `place_bet`、`claim`、`settle` 确实互相争用。这是 Sui shared object 模型的固有特性——同一个 shared object 的所有写交易必须排序执行。

但实际上这不是问题：

- Sui 单个 shared object 可以承受**数千 TPS**，对于预测竞猜的并发量绰绰有余
- 每笔 `place_bet` / `claim` 的执行逻辑很轻（加减 Balance、更新计数器），不会阻塞
- 我们已经把不同市场拆成了独立 shared object，SUI/USD 的投注不阻塞 BTC/USD
- 这和 Sui 上所有 DEX（Cetus、Turbos）的 Pool 对象是同一个模式

真正需要担心的是**跨市场争用**（已解决）。同市场内的排序执行，对于 Tide 的业务量级不会成为瓶颈。

## 2. 事件索引器

具体来说有两层：

**第一层：Sui 节点自带的事件查询（无需额外部署）**

Sui 节点（fullnode）本身就存储所有历史事件，通过 gRPC / GraphQL 直接查询：

```graphql
# GraphQL 示例：查某市场的历史结算事件
{
  events(
    filter: { eventType: "<package>::tide::RoundSettled" }
    first: 10
    after: "<cursor>"
  ) {
    nodes {
      json        # { market_id, round_id, result, open_price, close_price, ... }
      timestamp
    }
    pageInfo { hasNextPage, endCursor }
  }
}
```

对于基础的历史翻页查询，直接用这个就够了，不需要自建服务。

**第二层：自建索引器（排行榜等复杂聚合需要时）**

```
Sui Node ──事件流──▶ Indexer Service ──写入──▶ PostgreSQL/SQLite
                    (TS/Rust 脚本)              │
                                                ▼
                    Frontend ◀──查询──── REST API / GraphQL
```

排行榜需要 `GROUP BY player ORDER BY net_profit DESC LIMIT 10` 这类聚合查询，链上 API 做不到，需要数据库。但这是 Phase 2 的事。

**MVP 阶段**：直接用 Sui 节点的 gRPC/GraphQL 事件查询，零额外基础设施。

## 3. 用户个人数据

两个数据源配合：

### 未结算的 Ticket（链上对象查询）

Ticket 是用户拥有的 owned object，直接按类型 + 所有者查：

```graphql
{
  objects(
    filter: {
      owner: "0xUSER_ADDRESS"
      type: "<package>::tide::Ticket"
    }
  ) {
    nodes {
      # 每个 Ticket: market_id, round_id, direction, amount
    }
  }
}
```

这返回用户当前持有的所有 Ticket（待领奖 / 待退款 / 进行中）。Claim/refund 后 Ticket 被销毁，自动消失。

### 历史记录（事件查询）

已销毁的 Ticket 查不到了，但事件永久存在：

```graphql
# 用户的下注记录
events(filter: { eventType: "<package>::tide::BetPlaced", sender: "0xUSER" })

# 用户的领奖记录
events(filter: { eventType: "<package>::tide::Claimed", sender: "0xUSER" })

# 用户的退款记录
events(filter: { eventType: "<package>::tide::Refunded", sender: "0xUSER" })
```

### 前端展示逻辑

```
我的竞猜记录:
┌──────┬────────┬──────┬────────┬────────┬────────┐
│ 轮次 │ 市场    │ 方向  │ 投注    │ 结果    │ 盈亏    │
├──────┼────────┼──────┼────────┼────────┼────────┤
│ #127 │ SUI/USD│ UP ▲ │ 10 SUI │ 胜 ✅   │ +8.5   │  ← 来自 Claimed 事件
│ #126 │ SUI/USD│ DN ▼ │ 5 SUI  │ 负 ❌   │ -5     │  ← 来自 BetPlaced 且无对应 Claimed
│ #125 │ SUI/USD│ UP ▲ │ 5 SUI  │ 平 ➖   │ 0      │  ← 来自 Refunded 事件
│ #128 │ SUI/USD│ UP ▲ │ 10 SUI │ 待结算  │ -      │  ← 来自 owned Ticket 对象
└──────┴────────┴──────┴────────┴────────┴────────┘

汇总统计（前端聚合）:
  总场次: 42  |  胜: 20  |  负: 15  |  平: 7
  总投入: 350 SUI  |  总收回: 412 SUI  |  净盈亏: +62 SUI
```

汇总数据由前端遍历事件后在本地计算。数据量不大（一个用户几百上千条），前端处理毫无压力。

### 小结

| 数据需求 | 数据源 | 额外基础设施 |
|---------|--------|------------|
| 当前持有 Ticket | 链上对象查询 (owned objects) | 无 |
| 历史投注/领奖/退款 | 链上事件查询 (events) | 无 |
| 用户个人汇总 | 前端本地聚合事件数据 | 无 |
| 排行榜 Top N | 自建索引器 + 数据库 | Phase 2 需要 |

MVP 阶段完全不需要额外后端服务（除了 Keeper），所有查询走 Sui 节点 gRPC 即可。

需要我更新设计文档吗？

## 👤 User
*2026-02-08T14:50:30.304Z*

我们聊清楚，sui 节点自带的事件查询，支持倒序查询吗？（如果支持，Market 都不需要内置recent_settlesd_ids，同时也能方便显示用户的操作记录）。
第二点，如果用户频繁操作，导致历史记录很多，这要怎么聚合？这类情况稀少，依旧强行查出来。又或者是明确指出只查询前1000条操作记录？

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T14:51:04.193Z*

## 1. 倒序查询

支持。Sui GraphQL 遵循 Relay Connection 规范：

- `first: N, after: cursor` → 正序（旧→新）
- `last: N, before: cursor` → **倒序（新→旧）**

```graphql
{
  events(
    filter: { eventType: "<package>::tide::RoundSettled" }
    last: 5           # 最近 5 条，倒序
  ) {
    nodes { json, timestamp }
    pageInfo { hasPreviousPage, startCursor }
  }
}
```

既然如此，**`recent_settled_ids` 确实可以去掉**。Market 结构精简为：

```
Market (shared)
├── id: UID
├── registry_id: ID
├── pyth_feed_id: vector<u8>
├── interval_ms: u64
├── status: u8
├── round_count: u64
├── current_round_id: Option<ID>      ← LIVE 轮
├── upcoming_round_id: Option<ID>     ← UPCOMING 轮
└── rounds: ObjectTable<u64, Round>   ← 全量存储
```

前端查最近 3 轮结算结果：直接倒序查 `RoundSettled` 事件，不走 ObjectTable。

## 2. 历史记录聚合

先估算数据量：一个用户每天 10 笔，一年 ~3,650 条。重度用户可能上万条。这个量级前端聚合完全没压力。

策略就是**分页加载 + 渐进聚合**：

```
首屏:
  → last: 20 条记录（倒序），立即显示
  → 同时发起聚合请求

聚合:
  → 分批拉取全部事件（每批 50-100 条，自动翻页）
  → 前端累加计算 wins/losses/total_bet/net_profit
  → 设一个上限，比如最多拉 5000 条
  → 如果触及上限，显示"统计基于最近 5000 条记录"
```

这个上限不太会被触碰——5000 条意味着每天 10 笔连续操作一年半。但有这个兜底比没有好。

对于绝大多数用户，全量拉取就几十到几百条，几次 RPC 调用就结束了。

---

要我把这轮讨论的变更（去掉 `recent_settled_ids`、事件查询策略、用户数据聚合方案）更新到设计文档里？

## 👤 User
*2026-02-08T15:03:10.361Z*

我来说说结论

1. Market -> vector<ID> + object, Round -> ObjectTable<ID, Round> + cureent_round_id + upcoming_round_id
2. 页面显示 前x个轮次 + 当前轮次 + 下一轮次，（前x个轮次的数据使用 qraphql 查询）
3. 个人历史数据上，采用倒序显示，通过查询 BetPlaced + (Claimed/Refunded/CancelRound/SweepExpired等) 事件的形式，来显示信息

以上这三条的结论你先更新到文档中。
对于用户聚合数据的方案中，能不能采用存储用户数据的形式？这对于存储/更新/查询等开销的影响如何？对于费用上的影响如何？用户数量的影响如何？以及这个能否对排行榜有影响？

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T15:03:51.295Z*

先更新文档中的三条结论。

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T15:04:03.163Z*

Now I'll apply the three updates: object model, data query strategy, and user data section.

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T15:04:56.362Z*

Now update the frontend data query section and user data section:

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T15:05:34.584Z*

Now update the events to include more event types:

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T15:06:11.804Z*

文档已更新完毕。

---

现在回答你关于**链上存储用户聚合数据**的问题。

## 链上 UserStats 方案分析

设计方式：UserStats 作为用户的 **owned object**，每个用户每个市场一个。

```
UserStats (owned by user)
├── market_id: ID
├── total_rounds: u64
├── wins / losses / draws: u64
├── total_bet / total_won: u64
└── net_profit: i64    // Move 没有原生 i64，需用 u64 + bool 表示
```

### 开销分析

| 维度 | 影响 |
|------|------|
| **存储** | 每个 UserStats ~100 bytes，首次创建需支付存储押金（约 0.003 SUI），可忽略 |
| **更新 gas** | 每次 place_bet / claim / refund 多写一个 owned object，增加约 0.001-0.002 SUI gas |
| **争用** | **零额外争用**——owned object 只有所有者的交易会触碰，不影响任何其他用户 |
| **用户规模** | 1 万用户 × 3 市场 = 3 万个 UserStats 对象，分散在各用户名下，对链无任何压力 |

### 核心问题：函数签名

`place_bet` 需要接收 `&mut UserStats`，但用户首次下注时没有这个对象。Sui Move 函数签名固定，不支持可选参数。处理方式：

**方案 A：两个入口函数**
```move
// 首次下注，创建 UserStats 并返还给用户
public fun place_bet_first(market: &mut Market, ..., ctx: &mut TxContext)

// 后续下注，传入已有 UserStats
public fun place_bet(market: &mut Market, ..., stats: &mut UserStats, ctx: &mut TxContext)
```
前端检测用户是否持有 UserStats 对象，调不同函数。

**方案 B：独立创建**
```move
public fun create_user_stats(market_id: ID, ctx: &mut TxContext)  // → 转给 sender
public fun place_bet(market: &mut Market, ..., stats: &mut UserStats, ...)
```
首次使用时前端自动在同一笔交易里先 create 再 place_bet（PTB 支持）。

方案 B 更干净——`place_bet` 只有一个版本，逻辑不分叉。

### 对排行榜的影响

**没有直接帮助。** 链上仍然无法做 `ORDER BY net_profit DESC LIMIT 10`。但间接好处：

- 索引器可以直接读取 UserStats 对象获取聚合数据，不需要从头重放事件计算
- 首次启动 / 数据库清空后的恢复速度更快——扫描 UserStats 对象类型即可，不需要逐条事件回放
- 数据一致性有链上保证，索引器只是搬运而非计算

### 总结对比

| | 纯事件方案 | 链上 UserStats |
|---|---|---|
| 合约复杂度 | 低 | 中（多一个对象 + 创建逻辑） |
| 用户 gas 开销 | 基准 | 每笔操作多 ~0.001 SUI |
| 前端聚合 | 需遍历事件，首屏可能慢 | 一次 getObject 读取，即时 |
| 排行榜索引恢复 | 从头回放事件 | 扫描 UserStats 对象 |
| 数据可信度 | 链上事件不可篡改 | 链上对象不可篡改 |

如果你觉得"用户首屏即时显示聚合数据"的体验值得多付一点 gas 和合约复杂度，链上 UserStats 是合理的。要不要采用？

## 👤 User
*2026-02-08T15:15:37.470Z*

1. Round 存储采用 ObjectTable 后，其他东西想要引用记录的时候，就只能存储 round_number 了是吗？可以存储 round_id + round_number 吗？
2. 我觉得用 UserState 挺好的，前端聚合和排行榜索引都方便了许多，没法做到在合约中的 place_bet 时，检索到用户 UserState 吗？如果是前端发起的 create_user_stats，不会出现数据不一致的问题吗？比如发起了两次请求都包含 create_user_stats。

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T15:16:57.376Z*

## 1. round_id + round_number

可以，而且建议两个都存。它们是不同层面的标识：

- `round_number: u64`：序号，用于 ObjectTable 查找和业务逻辑（"第几轮"）
- `round_id: ID`：Sui 对象 ID（`UID` 里的 `ID`），用于链下直接查询对象

Ticket 存两个就行：

```
Ticket (owned)
├── market_id: ID
├── round_id: ID           ← 直接查 Round 对象
├── round_number: u64      ← 业务语义 + ObjectTable key
├── direction: u8
└── amount: u64
```

## 2. UserStats：用 dynamic field 替代 owned object

你说的两个问题都很准确——owned object 方案确实有这些缺陷。但换个存储方式就全部解决了：**把 UserStats 存为 Market 上的 dynamic field，以用户地址为 key。**

```move
// place_bet 内部逻辑
let sender = tx_context::sender(ctx);

if (dynamic_field::exists_(&market.id, sender)) {
    // 已有 → 直接更新
    let stats = dynamic_field::borrow_mut(&mut market.id, sender);
    stats.total_rounds = stats.total_rounds + 1;
    stats.total_bet = stats.total_bet + amount;
} else {
    // 没有 → 自动创建
    dynamic_field::add(&mut market.id, sender, UserStats {
        total_rounds: 1,
        total_bet: amount,
        wins: 0, losses: 0, draws: 0,
        total_won: 0,
    });
};
```

**为什么没有竞态问题：** `place_bet` 已经需要 `&mut Market`，同一个 Market 的所有交易本来就是串行执行的。两笔 `place_bet` 不可能同时进入，第二笔一定能看到第一笔创建的 UserStats。

**和 owned object 方案对比：**

| | owned object | dynamic field on Market |
|---|---|---|
| 函数签名 | 需要用户传入，首次需特殊处理 | 合约内部自动处理，用户无感 |
| 重复创建风险 | 有 | 不可能 |
| 额外争用 | 无 | 无（Market 本来就要锁） |
| 链下查询 | `getOwnedObjects(user, type=UserStats)` | `getDynamicFieldObject(market_id, sender)` |
| 索引器扫全量 | 按类型扫所有 UserStats 对象 | 遍历 Market 的 dynamic fields |

`place_bet` 的函数签名变得更干净——用户不需要管理额外对象：

```move
public fun place_bet(
    market: &mut Market,
    direction: u8,
    payment: Coin<SUI>,
    clock: &Clock,
    ctx: &mut TxContext,
)
// 内部自动创建/更新 UserStats，对用户完全透明
```

`claim` / `refund` 同理，内部 `borrow_mut` UserStats 更新胜负和盈亏数据。

需要我把这两点更新到设计文档里吗？

## 👤 User
*2026-02-08T15:22:26.843Z*

1. Ticket 存储 round_id + round_number 方便查询
2. UserStats 能不能也用 ObjectTable<address, UserStats> 的形式？ 有什么差别？

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T15:23:03.061Z*

可以。`ObjectTable<address, UserStats>` 本质上就是 `dynamic_object_field` 的类型安全封装，和裸 `dynamic_field` 的区别：

| | `dynamic_field` | `ObjectTable<address, UserStats>` |
|---|---|---|
| UserStats 是否为 Sui 对象 | 否（普通 struct） | 是（需要 `key + store`，有 UID） |
| 独立 object ID | 无 | 有 → 可直接 `getObject(stats_id)` 查询 |
| 辅助方法 | 手动写 `exists_` / `borrow_mut` | 自带 `contains`, `borrow_mut`, `length()` |
| `length()` | 无 | 有 → **可直接获取该市场的总用户数** |
| 链下查询 | 只能通过 `getDynamicField(market, key)` | 额外支持直接按 object ID 查 |
| 存储开销 | 略低 | 每个 UserStats 多一个 UID（8 bytes），可忽略 |

用 `ObjectTable` 更好。API 更干净，`length()` 白送一个用户计数，每个 UserStats 有独立 object ID 方便链下查询。

Market 结构变为：

```
Market (shared)
├── ...
├── rounds: ObjectTable<u64, Round>
└── user_stats: ObjectTable<address, UserStats>
```

合约代码几乎一样，只是换个 API：

```move
if (market.user_stats.contains(sender)) {
    let stats = market.user_stats.borrow_mut(sender);
    // 更新
} else {
    market.user_stats.add(sender, UserStats { id: object::new(ctx), ... });
};
```

我把这些都更新到文档里。

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T15:24:09.461Z*

Now update the leaderboard section to reflect that UserStats is on-chain:

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T15:24:42.310Z*

文档已更新。变更点：

- **Ticket**：增加 `round_id: ID` 字段，与 `round_number` 并存
- **Market**：新增 `user_stats: ObjectTable<address, UserStats>`
- **UserStats**：完整结构定义，明确为合约自动管理（用户无需传入）
- **排行榜**：改为链上 UserStats + 链下索引方案，索引器直接扫描 UserStats 对象而非回放事件

## 👤 User
*2026-02-08T15:26:49.062Z*

照你这个说法，实际上都不需要 ObjectTable，直接用 Table 是不是就可以？因为 UserStats 没有必要是一个单独的object，然后你看看对于 bet/claim/refund/sweep 都有影响吗？

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T15:27:39.285Z*

对，`Table<address, UserStats>` 就够了。UserStats 不需要被独立寻址——查询时永远是 "某个 Market 下的某个用户"，不存在只有 object ID 没有 Market + address 的场景。

```
Table<address, UserStats>:
  查询: getDynamicFieldObject(market_id, { type: "address", value: "0xUSER" })
  遍历: getDynamicFields(market_id) → 分页拿全部 UserStats

UserStats 简化为普通 struct (只需 store，不需要 key + UID):
  struct UserStats has store {
      total_rounds: u64,
      wins: u64,
      draws: u64,         // losses = total_rounds - wins - draws，不用存
      total_bet: u64,
      total_won: u64,
  }
```

各函数影响：

| 函数 | UserStats 操作 | 说明 |
|------|---------------|------|
| `place_bet` | `total_rounds++`, `total_bet += amount` | 不存在则 `table::add`，否则 `borrow_mut` |
| `claim` | `wins++`, `total_won += reward` | `borrow_mut`，一定已存在 |
| `refund` | `draws++` | `borrow_mut`，一定已存在 |
| `sweep_expired` | **不涉及** | 只移动 Round 剩余 Balance → treasury，不碰个人数据 |

`losses` 不需要单独存储，前端算 `total_rounds - wins - draws` 即可。`net_profit` 同理：`total_won - total_bet`。减少链上写入。

我更新文档。

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T15:28:33.434Z*

Now update the leaderboard section:

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T15:28:46.613Z*

已更新。UserStats 从 `ObjectTable` 的独立对象简化为 `Table` 的普通 struct，去掉 UID 开销，去掉 `losses` / `net_profit` 存储字段改为前端派生计算。

## 👤 User
*2026-02-08T15:36:23.037Z*

现在继续讨论，关于 Ticket 对象，是用户在每个轮次 round 在下注place_bet时生成一个，并且如果用户胜利时，可以通过 claim 来销毁并获取奖金（refund同理），那么对于失败场景呢？这个对象就一直存在吗？对于胜利但是过期未领的场景呢？同时引申出另一个问题，sweep 有必要吗？赢得的奖金即使未操作，也应该一直保留吧？（可以在界面显示自己拥有且还未兑现的ticket，以高亮claim按钮啥的）

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T15:37:02.864Z*

很好的观察。逐个理清：

## Ticket 生命周期

当前问题：赢了有 `claim`，平局/取消有 `refund`，**输了没有对应操作**，Ticket 永远残留在钱包里。

解法：把 `claim` / `refund` 合并为一个 **`redeem`**，处理所有场景：

| Round 结果 | redeem 行为 |
|-----------|------------|
| 胜利 | 计算奖金，扣手续费，支付给用户，销毁 Ticket |
| 失败 | 销毁 Ticket，不支付 |
| 平局 | 全额退款，销毁 Ticket |
| 取消 | 全额退款，销毁 Ticket |

一个函数处理全部情况，每个 Ticket 最终都会被销毁，不存在残留。前端根据 Round 结果显示不同文案：

```
胜利 Ticket → [领取奖金 🎉]    (高亮)
失败 Ticket → [确认结果]       (次要样式)
平局 Ticket → [领取退款]
```

## sweep 有没有必要

你说得对，**没必要**。

去掉 sweep 后：
- 赢家的奖金永远保留在 Round pool 里，随时可 redeem
- 不存在"过期作废"的风险，对用户更友好
- 合约去掉 `sweep_expired` 函数、`expiry_ms` 配置
- Round 对象会一直存在（ObjectTable 里），但不影响性能（O(1) 访问）

唯一的代价：如果某用户丢失私钥，他那份奖金永远锁在 Round pool 里。但这是极端小概率事件，金额也有限，不值得为此增加一整套过期回收机制。

更新到文档。

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T15:37:38.889Z*

Now apply all edits: remove expiry_ms, merge claim/refund into redeem, remove sweep, update fund flow and edge cases.

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T15:39:14.733Z*

Now update the Round lifecycle diagram to remove EXPIRED:

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T15:39:31.464Z*

Now update events to replace Claimed/Refunded with Redeemed:

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T15:39:49.827Z*

Update the data query section in frontend:

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T15:40:08.205Z*

Update the security section to remove expiry references:

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T15:40:25.307Z*

文档已全部更新。变更汇总：

- **`claim` + `refund` 合并为 `redeem`**：一个函数处理胜/负/平/取消四种场景，所有 Ticket 最终都被销毁
- **移除 `sweep_expired`**：奖金永久保留在 Round pool，不设过期
- **移除 `expiry_ms` 配置**
- **Round 状态机**：去掉 EXPIRED 状态
- **事件**：`Claimed` + `Refunded` 合并为 `Redeemed`，携带 `outcome` 和 `payout` 字段
- **UserStats 更新时机**：在 `redeem` 中根据 outcome 更新

## 👤 User
*2026-02-08T15:45:45.274Z*

你动作有点太快了。。。对于用户而言，他为什么要 redeem 失败的ticket？那么在前端上，实际上是查询用户拥有的所有ticket（已操作的已经被销毁了），按下按钮后，就把可操作的（round=settle)的ticket都调用吗？

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T15:46:35.667Z*

你说得对，没人会主动花 gas 去销毁一张输了的 ticket。

但合约层面 `redeem` 支持处理失败 ticket 仍然有意义——关键在前端怎么用它。

## 前端流程

```
1. 查询用户拥有的所有 Ticket (owned objects)
2. 对每张 Ticket，读取对应 Round 的 status + result
3. 分类展示:

   可操作 (Round = SETTLED 或 CANCELLED):
     ├── 胜利 ticket → [领取奖金] 高亮
     ├── 平局/取消 ticket → [领取退款]
     └── 失败 ticket → 显示"已结算"，不需要单独按钮

   进行中 (Round = LIVE):
     └── 等待结算...

   待开盘 (Round = UPCOMING):
     └── 已下注，等待开盘...

4. 用户点击 [一键领取]
   → PTB 中批量调用 redeem：
      - 胜利 ticket → 领钱 + 销毁
      - 平局/取消 ticket → 退款 + 销毁
      - 失败 ticket → 顺带销毁（清理钱包）
   → 一笔交易完成，一次 gas
```

用户感知到的是"领取奖金"，失败 ticket 的销毁只是搭便车，用户不需要关心。Sui 的 PTB 天然支持一笔交易内调用多次 `redeem`。

如果用户不点领取，失败 ticket 就一直在钱包里——无害，只是有点碍眼。这也是可接受的。

所以合约不用改，`redeem` 统一处理四种情况是合理的。区别只在前端**不给失败 ticket 单独的操作按钮**，而是在批量领取时静默清理。

## 👤 User
*2026-02-08T15:47:46.110Z*

行，那么继续更新文档吧

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T15:49:12.021Z*

已更新。主要补充了"我的记录页"的完整 UI 布局和 PTB 批量 redeem 的交互逻辑。

## 👤 User
*2026-02-08T15:51:19.965Z*

你觉得还有什么需要讨论注意的吗？

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T15:52:14.955Z*

过了一遍整体设计，有几个点值得在编码前确认：

## 1. Treasury 放在哪

当前 treasury 在 Registry 上。但 `redeem` 操作在 Market 上——胜方领奖时手续费要转入 treasury，这意味着 `redeem` 需要 `&mut Registry`。这就导致**所有市场的 redeem 又争用 Registry 了**，打破了 Market 独立的初衷。

建议：**每个 Market 持有自己的 treasury**，管理员分别从各 Market 提取。

```
Market (shared)
├── ...
├── treasury: Balance<SUI>    ← 手续费在 Market 内部流转，不碰 Registry
└── ...
```

## 2. 全局暂停怎么检查

同样的问题：`place_bet(market)` 怎么检查 Registry 的 `global_status`？如果传 `&Registry`，又引入争用。

两个选项：
- **传 `&Registry`（只读）**：Sui 的 shared object 只读访问不走共识排序，不产生写争用。需要确认 Sui 当前是否支持这一点。
- **冗余存储**：每个 Market 存一份 `global_paused: bool`，`pause_global` 时遍历更新所有 Market。市场数量是个位数，可行。

## 3. 结算用一个价格还是两个

`settle_and_advance` 同时做：结算 Round N（需要收盘价）+ 启动 Round N+1（需要开盘价）。但这两个价格在同一时刻——**是同一个价格**。

```
Round N 收盘价 = Round N+1 开盘价 = settle 时刻的 Pyth 价格
```

合约只需要接收一个 `PriceInfoObject`，同时用于两个用途。这简化了 Keeper 逻辑。

## 4. Keeper 故障恢复

如果 Keeper 挂了、延迟了，`price_tolerance_sec` 会拒绝过期价格，settlement 失败。这时候 LIVE 轮就卡住了。

需要一个恢复路径：
- 管理员 `cancel_round` 取消当前卡住的 LIVE 轮 → 所有投注者可 redeem 退款
- 然后重新 `start_first_round` 恢复市场运行

## 5. 同一用户重复下注

用户能否在同一轮同一方向下注两次？或者同时下注 UP 和 DOWN？

- 允许的话：会生成多张 Ticket，多几个对象但逻辑简单
- 禁止的话：需要在合约里检查去重，增加复杂度

建议**允许**。下注两边是经济上不理性的（手续费保证亏损），不需要合约去管。多张 Ticket 在 redeem 时逐个处理即可。

---

这几点确认后设计就基本完整了，可以开始编码。

## 👤 User
*2026-02-08T16:07:12.321Z*

1. Treasury 的问题，能不能在 settled 时就统一转入？这样只有在轮次正常结束时，才会发生一次。现在的设计是 5min 一个轮次，可以说所有 Market Round 的 settled 都是同时进行的。哪怕未来有不同时间间隔的，也没啥大问题，毕竟 Market数量有限，并不会出现竞争问题。
2. 全局暂停这个概念就取消掉吧
3. 结算价格用同一个价格，简化设计
4. 暂时不考虑 keeper 故障问题，未来进行设计（比如开放 settle 权限，提供激励，鼓励第三方bot来做操作）。你提到的恢复路径也不错，keeper重启后，直接检测 live round 是否过期，如果过期则自动提交 cancel and start new 的操作（是否复用 settle_and_adance？如果复用，价格又该怎么处理？）
5. 允许一个用户重复下注（每次下注都生成一个 ticket，哪怕重复方向）

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T16:07:47.437Z*

逐个确认并回应：

## 1. Treasury 在 settle 时转入

可行。在 `settle_and_advance` 时根据结果决定是否扣费：

```
settle_and_advance(settler, registry, market, clock, pyth_price):
  ├── 记录收盘价，判定结果
  ├── 如果正常胜负（有赢家有输家）:
  │     fee = pool * fee_bps / 10000
  │     从 Round.pool 转 fee → Registry.treasury
  ├── 如果平局/单边:
  │     不扣费，pool 全额保留用于退款
  ├── UPCOMING → LIVE（开盘价 = 同一个收盘价）
  └── 创建新 UPCOMING Round
```

这样 `redeem` 只需 `&mut Market`，不碰 Registry。`settle_and_advance` 传 `&mut Registry` 但每 5 分钟才一次，无争用问题。

## 4. Keeper 故障恢复

关于复用 `settle_and_advance`：不太合适，因为正常结算需要有效价格，过期场景恰恰没有有效价格。

更自然的路径是 keeper 重启后检测到过期 LIVE round → `cancel_round` + `start_first_round`，两步操作可合并到一个 PTB 里。这两个函数已经在设计中，不需要新增。具体实现留到后续。

---

更新文档。

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T16:07:57.769Z*

批量更新：1) treasury 移到 Market，fee 在 settle 时转入；2) 去掉全局暂停；3) 结算用同一价格；4) 允许重复下注；5) 更新资金流和函数表。

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T16:09:27.586Z*

Now update edge cases and pause section:

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T16:09:49.102Z*

Update the leaderboard section to fix stale references:

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T16:10:00.875Z*

Update dev plan and security section:

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T16:10:32.776Z*

Update the architecture diagram to remove stale references:

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T16:10:50.528Z*

文档已全部更新，变更汇总：

- **Treasury 移至 Market**：每个 Market 独立持有 treasury，`settle_and_advance` 时扣费转入，`redeem` 不碰 Registry
- **去掉全局暂停**：只保留市场级 `pause_market` / `resume_market`
- **结算用同一价格**：Round N 收盘价 = Round N+1 开盘价
- **允许重复下注**：同用户同轮次可多次下注
- **`settle_and_advance` 不再需要 `&mut Registry`**：只操作 `&mut Market`，彻底消除跨市场争用
- **Registry 简化**：只存 config + market_ids，不再持有 treasury 和 global_status

## 👤 User
*2026-02-08T16:18:59.649Z*

1. 我的意思是，依然由 Regitry 持有 treasury，但是是在 round settle 时更新数据（因为 market 数量有限，所以不会有竞争问题）
2. 我看你在资金流中的兑现计算过程中，使用 remain_pool，应该错了吧？随着treasury转移和用户对象，remain_pool的数据会越来越少的，我看可以用 round.up_amount 和 round.down_amount 作为 pool_amount 来计算（在计算中，会不会出现进1/退1，导致最后一个用户无法提现足够的资金/用户都提现完后剩余非常稀少的资金？）

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T16:19:56.682Z*

两个好问题。

## 1. Treasury 回到 Registry

明白了，`settle_and_advance` 传 `&mut Registry` 存入手续费，每个市场每 5 分钟才一次，无争用。`redeem` 只需 `&mut Market`。

## 2. 奖金计算

你说得对，不能用 remaining pool（动态余额），必须用固定值。在 settle 时预计算并存储：

```
settle_and_advance 时:
  total_pool = up_amount + down_amount
  if 正常胜负:
    fee = total_pool × fee_bps / 10000 → Registry.treasury
    round.prize_pool = total_pool - fee    ← 存储到 Round，固定值
  if 平局/单边:
    round.prize_pool = total_pool          ← 不扣费

redeem 时:
  reward = round.prize_pool × (my_bet / winning_total)   ← 用固定值计算
  从 round.pool (Balance) 中取出 reward 转给用户
```

**关于精度丢失：** Move 整数除法向下取整，每次 redeem 的 reward 都是 floor 值。最坏情况：n 个赢家，累计误差最多 n-1 个最小单位（MIST，即 10^-9 SUI）。

- 100 个赢家 → 最多 99 MIST（≈ 0.000000099 SUI）留在 pool
- 最后一个用户照常提现，不会出现余额不足
- 这是 DeFi 标准处理方式，dust 可忽略

同时 Round 需要增加一个字段：

```
Round
├── ...
├── prize_pool: u64         ← settle 时计算并存储，redeem 时用于计算奖金
└── ...
```

更新文档。

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T16:21:24.072Z*

Now update the fund flow section:

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T16:21:58.241Z*

文档已更新。变更汇总：

- **Treasury 回到 Registry**：`settle_and_advance` 传 `&mut Registry` + `&mut Market`，settle 时扣费转入
- **Round 新增 `prize_pool: u64`**：settle 时计算并存储固定值，redeem 时基于此值计算奖金
- **奖金计算公式修正**：`reward = round.prize_pool × (my_bet / winning_total)`，使用固定值而非动态余额
- **精度说明**：整数除法向下取整，dust 最多 n-1 MIST，不影响任何用户提现

## 👤 User
*2026-02-08T16:31:33.541Z*

现在还有未讨论的点吗？

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T16:32:16.903Z*

过了一遍完整设计，核心的都讨论清楚了。剩下的都是编码阶段的实现细节，不影响架构决策：

- Round 时间校验（`expected_end_time = open_timestamp_ms + interval_ms`，合约内可推导）
- Pyth feed ID 在合约内的硬校验（已在预言机章节提及）
- `place_bet` 校验 UPCOMING round 存在性
- Move.toml 添加 Pyth 依赖
- Keeper 可以用单个 PTB 批量结算所有市场（一笔 tx 完成）

这些在写代码时自然会处理。设计阶段可以收尾了，准备开始编码的时候告诉我。

## 👤 User
*2026-02-08T16:33:51.307Z*

现在这个文档 @docs/design.md 有点太大了，你能帮我适当拆分吗？

## 🤖 Assistant (claude-opus-4-6)
*2026-02-08T16:34:38.730Z*

拆分方案：

- `docs/design.md` — 总览（背景、架构、开发规划、安全、参考）
- `docs/contract.md` — 合约设计（对象模型、Round、函数、资金流、边界情况、暂停）
- `docs/oracle.md` — 预言机 + 结算机制 + Keeper
- `docs/frontend.md` — 前端 + 排行榜 + 数据查询
